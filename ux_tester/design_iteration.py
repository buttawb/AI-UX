import PIL
from django.shortcuts import render
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import json
import requests
from PIL import Image
from io import BytesIO
from google import genai
from google.genai import types
from .views import FIGMA_TOKENS, AVIALDO_GEMINI_KEY
import os
import base64

# Design iteration prompt template for Gemini
GEMINI_DESIGN_ITERATION_PROMPT = """This is my figma screen, fix the below issues on this screen - Add two more messages in this chat.

CRITICAL INSTRUCTIONS FOR TEXT HANDLING:
1. DO NOT modify or regenerate any existing text
2. Keep all existing text exactly as is, with the same font, size, and position
3. Only add new text for the two messages
4. New text must match the exact font style, size, and quality of existing text
5. Do not blur, distort, or modify any text elements
6. Maintain exact pixel-perfect alignment of all text"""


def design_iteration_view(request):
    """
    View function for the design iteration page.
    """
    return render(request, 'design_iteration.html')

def generate_with_gemini(image, prompt):
    """Generate design iteration using Gemini API"""
    # Initialize the Gemini client
    client = genai.Client(api_key=AVIALDO_GEMINI_KEY)
    
    # Create a more explicit prompt for image generation
    text_input = GEMINI_DESIGN_ITERATION_PROMPT.format(user_prompt=prompt)
    
    # Ensure image is in highest quality and preserve text
    if image.mode != 'RGBA':
        image = image.convert('RGBA')
    
    # Save a high-quality version of the original for reference
    reference_path = "static/generated_images/reference_design.png"
    os.makedirs(os.path.dirname(reference_path), exist_ok=True)
    image.save(reference_path, 'PNG', quality=100, optimize=False)
    
    response = client.models.generate_content(
        model="gemini-2.0-flash-preview-image-generation",
        contents=[text_input, image],
        config=types.GenerateContentConfig(
            response_modalities=['TEXT', 'IMAGE'],
        )
    )

    if response.candidates:
        # Handle both text and image responses
        text_response = ""
        image_response = None
        
        for part in response.candidates[0].content.parts:
            if part.text is not None:
                text_response += part.text
            elif part.inline_data is not None:
                # Convert the image data directly to a PIL Image
                image_response = Image.open(BytesIO(part.inline_data.data))
                
                # Ensure the generated image matches original dimensions
                if image_response.size != image.size:
                    image_response = image_response.resize(image.size, Image.Resampling.LANCZOS)
                
                # Save the generated image with maximum quality
                output_path = "static/generated_images/generated_design.png"
                os.makedirs(os.path.dirname(output_path), exist_ok=True)
                image_response.save(output_path, 'PNG', quality=100, optimize=False)

        if not image_response:
            print("Warning: No image was generated by Gemini")
            
        return {
            "text": text_response,
            "image": image_response
        }
    return None

@csrf_exempt
def generate_iteration(request):
    """
    API endpoint to generate design iterations.
    """
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            figma_token = data.get('figma_token')
            design_data = data.get('design_data')
            iteration_prompt = data.get('iteration_prompt', '')

            if not figma_token:
                return JsonResponse({"error": "No access token provided"}, status=400)

            # Get the actual token value if it's a predefined token
            if figma_token in FIGMA_TOKENS:
                figma_token = FIGMA_TOKENS[figma_token]

            # Fetch Figma file data
            file_id = design_data.get('id')
            if not file_id:
                return JsonResponse({"error": "No Figma file ID provided"}, status=400)

            # Fetch Figma file structure
            figma_url = f"https://api.figma.com/v1/files/{file_id}"
            headers = {"X-Figma-Token": figma_token}
            figma_response = requests.get(figma_url, headers=headers)
            
            if figma_response.status_code != 200:
                return JsonResponse({"error": "Failed to fetch Figma file"}, status=400)

            figma_data = figma_response.json()

            # Extract frames and their images
            frames = []
            for canvas in figma_data.get('document', {}).get('children', []):
                for frame in canvas.get('children', []):
                    if frame.get('type') == 'FRAME':
                        frames.append({
                            'id': frame.get('id'),
                            'name': frame.get('name'),
                            'node': frame
                        })

            if not frames:
                return JsonResponse({"error": "No frames found in Figma file"}, status=400)

            # Take the first frame
            selected_frame = frames[0]
            
            # Fetch frame image with maximum quality (scale=4 for highest resolution)
            image_url = f"https://api.figma.com/v1/images/{file_id}?ids={selected_frame['id']}&format=png&scale=4"
            image_response = requests.get(image_url, headers=headers)
            
            if image_response.status_code != 200:
                return JsonResponse({"error": "Failed to fetch frame image"}, status=400)

            image_data = image_response.json().get('images', {})
            frame_image_url = image_data.get(selected_frame['id'])
            
            if not frame_image_url:
                return JsonResponse({"error": "Failed to get frame image URL"}, status=400)

            # Download and save the original image
            img_response = requests.get(frame_image_url)
            if img_response.status_code == 200:
                # Create PIL Image from the response content
                original_image = Image.open(BytesIO(img_response.content))
                
                # Save original image with maximum quality
                original_path = "static/generated_images/original_design.png"
                os.makedirs(os.path.dirname(original_path), exist_ok=True)
                original_image.save(original_path, 'PNG', quality=100, optimize=False)

                # Generate iteration using Gemini
                response = generate_with_gemini(original_image, iteration_prompt)
                
                if response:
                    # Parse the text response as JSON
                    try:
                        text_data = json.loads(response['text'])
                    except json.JSONDecodeError:
                        text_data = {
                            "improved_design": {
                                "description": response['text'],
                                "key_changes": [response['text']]
                            }
                        }

                    # Convert original image to base64
                    with open(original_path, 'rb') as img_file:
                        original_base64 = base64.b64encode(img_file.read()).decode('utf-8')

                    # Convert generated image to base64
                    generated_path = "static/generated_images/generated_design.png"
                    with open(generated_path, 'rb') as img_file:
                        generated_base64 = base64.b64encode(img_file.read()).decode('utf-8')

                    return JsonResponse({
                        'status': 'success',
                        'data': {
                            'original_images': [{
                                'name': selected_frame['name'],
                                'image': original_base64
                            }],
                            'improved_design': {
                                'description': text_data.get('improved_design', {}).get('description', ''),
                                'key_changes': text_data.get('improved_design', {}).get('key_changes', []),
                                'image': generated_base64
                            }
                        }
                    })

            return JsonResponse({
                'status': 'error',
                'message': 'Failed to generate iteration'
            }, status=500)

        except Exception as e:
            print(f"Error in generate_iteration: {str(e)}")
            import traceback
            print(f"Traceback: {traceback.format_exc()}")
            return JsonResponse({
                'status': 'error',
                'message': f'An unexpected error occurred: {str(e)}'
            }, status=500)
    
    return JsonResponse({
        'status': 'error',
        'message': 'Method not allowed'
    }, status=405) 
