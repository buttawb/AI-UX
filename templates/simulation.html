{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI UX Tester - User Journey Simulation</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{% static 'css/styles.css' %}">
    <script>
        // Add static URL prefix for JavaScript
        const STATIC_URL = "{% static '' %}";
    </script>
    <style>
        .simulation-container {
            background-color: var(--surface);
            padding: 2rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            margin-bottom: 2rem;
            animation: slideUp 0.6s ease-out;
            border: 1px solid var(--border);
        }

        .nav-buttons {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            justify-content: center;
        }

        .nav-button {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
        }

        .nav-button:hover {
            transform: translateY(-2px);
            border-color: var(--primary);
            box-shadow: var(--shadow);
        }

        .nav-button.active {
            background: linear-gradient(135deg, var(--primary), #4f46e5);
            color: white;
            border-color: transparent;
        }

        .nav-button .icon {
            font-size: 1.2rem;
        }

        .nav-button .badge {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.8rem;
            margin-left: 0.5rem;
        }

        .nav-button:not(.active) .badge {
            background: var(--background);
            color: var(--primary);
        }

        .input-method-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .input-method-card {
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .input-method-card:hover {
            transform: translateY(-2px);
            border-color: var(--primary);
            box-shadow: var(--shadow);
        }

        .input-method-card.active {
            border-color: var(--primary);
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.05), rgba(79, 70, 229, 0.05));
        }

        .input-method-card .icon {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: var(--primary);
        }

        .input-method-card h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

        .input-method-card p {
            font-size: 0.9rem;
            color: var(--text-light);
            margin: 0;
        }

        .task-input-section {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border);
        }

        .task-input-section h3 {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text);
        }

        .task-suggestions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .task-suggestion-chip {
            background: var(--background);
            border: 1px solid var(--border);
            border-radius: 20px;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            color: var(--text);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .task-suggestion-chip:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .video-container {
            position: relative;
            width: 100%;
            max-width: 375px;  /* Match the canvas width */
            margin: 2rem auto;  /* Center the container */
            border-radius: var(--radius);
            overflow: hidden;
            background: var(--background);
            display: none;
            box-shadow: var(--shadow);
        }

        .video-container.active {
            display: block;
            animation: fadeIn 0.5s ease-out;
        }

        .video-container video {
            width: 100%;
            height: auto;
            border-radius: var(--radius);
            display: block;  /* Remove any extra space */
        }

        .video-controls {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
            background: rgba(0, 0, 0, 0.7);
            padding: 0.5rem;
            border-radius: var(--radius);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .video-container:hover .video-controls {
            opacity: 1;
        }

        .video-control-btn {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        .video-control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .download-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: var(--radius);
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .video-container:hover .download-btn {
            opacity: 1;
        }

        .download-btn:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        .file-upload-container {
            position: relative;
            margin-top: 1rem;
        }

        .file-upload-input {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            opacity: 0;
            cursor: pointer;
        }

        .file-upload-label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 1rem;
            background: var(--background);
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            color: var(--text-light);
            transition: all 0.2s ease;
        }

        .file-upload-label:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .file-upload-label .icon {
            font-size: 1.5rem;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .loading-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .loading-content {
            background: var(--surface);
            padding: 2rem;
            border-radius: var(--radius);
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid var(--border);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        .loading-text {
            color: var(--text);
            font-size: 1.1rem;
            font-weight: 500;
        }

        .loading-subtext {
            color: var(--text-light);
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        .loading-progress {
            margin-top: 1rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>User Journey Simulation</h1>
            <p>Watch AI simulate user interactions with your design to identify potential UX issues</p>
        </div>

        <div class="nav-buttons">
            <a href="/ux/upload_design/" class="nav-button">
                <span class="icon">📊</span>
                <span>UX Analysis</span>
                {% comment %} <span class="badge">Heatmap</span> {% endcomment %}
            </a>
            <a href="/ux/simulation/" class="nav-button active">
                <span class="icon">🎬</span>
                <span>User Journey</span>
                <span class="badge">New!</span>
            </a>
            <a href="/ux/design_iteration/" class="nav-button">
                <span class="icon">🔄</span>
                <span>Design Iteration</span>
                <span class="badge">New!</span>
            </a>
        </div>

        <div class="simulation-container">
            <div class="form-group">
                <label for="figmaAccessToken">Figma Access Token</label>
                <select id="figmaAccessToken" class="form-control">
                    <option value="">Select a token or enter custom...</option>
                    <option value="wahab_token">Wahab's Token</option>
                    <option value="ramsha_token">Ramsha's Token</option>
                    <option value="farzam_token">Farzam's Token</option>
                    <option value="custom">Enter Custom Token</option>
                </select>
                <div id="customTokenInput" style="display: none; margin-top: 0.5rem;">
                    <input type="text" id="customFigmaToken" class="form-control" placeholder="Enter your custom Figma access token">
                </div>
                <small class="form-text">Select a predefined token or enter your own Figma access token</small>
            </div>
            <div class="input-method-selector">
                <div class="input-method-card" data-method="figma">
                    <div class="icon">🎨</div>
                    <h3>Figma File</h3>
                    <p>Enter your Figma file ID to analyze</p>
                </div>
                <div class="input-method-card" data-method="upload">
                    <div class="icon">📁</div>
                    <h3>Upload Design</h3>
                    <p>Upload your design file directly</p>
                </div>
                <div class="input-method-card" data-method="url">
                    <div class="icon">🔗</div>
                    <h3>Design URL</h3>
                    <p>Provide a URL to your design</p>
                </div>
            </div>

            <div id="figmaInput" class="input-section">
                <div class="form-group">
                    <label for="figmaFileId">Figma File ID</label>
                    <input type="text" id="figmaFileId" class="form-control" placeholder="Enter your Figma file ID">
                    <small class="form-text">The unique identifier of your Figma file to analyze</small>
                </div>
            </div>

            <div id="uploadInput" class="input-section" style="display: none;">
                <div class="form-group">
                    <label>Upload Design File</label>
                    <div class="file-upload-container">
                        <input type="file" id="designFile" class="file-upload-input" accept=".fig,.sketch,.xd">
                        <label for="designFile" class="file-upload-label">
                            <span class="icon">📁</span>
                            <span>Click to upload or drag and drop</span>
                        </label>
                    </div>
                    <small class="form-text">Supported formats: Figma (.fig)</small>
                </div>
            </div>

            <div id="urlInput" class="input-section" style="display: none;">
                <div class="form-group">
                    <label for="designUrl">Design URL</label>
                    <input type="url" id="designUrl" class="form-control" placeholder="Enter the URL to your design">
                    <small class="form-text">Provide a direct link to your design file</small>
                </div>
            </div>

            <div class="task-input-section">
                <h3>What would you like to simulate?</h3>
                <div class="task-suggestions">
                    <div class="task-suggestion-chip">Buy a product</div>
                    <div class="task-suggestion-chip">Send a message</div>
                    <div class="task-suggestion-chip">Create an account</div>
                    <div class="task-suggestion-chip">Search for items</div>
                    <div class="task-suggestion-chip">Complete checkout</div>
                    {% comment %} <div class="task-suggestion-chip">Upload content</div> {% endcomment %}
                </div>
                <div class="form-group">
                    <label for="taskDescription">Task Description</label>
                    <textarea id="taskDescription" class="form-control" rows="3" placeholder="Describe the user journey you want to simulate..."></textarea>
                    <small class="form-text">Be specific about the steps and goals of the user journey</small>
                </div>

            <div id="simulationContainer" style="display:none; position: relative; margin-top: 20px;"></div>
            <a href="#" id="downloadSimulation" style="display:none; margin-top: 10px;">Download Simulation JSON</a>
            </div>

            <button id="startSimulationBtn" class="form-control">Start Simulation</button>


        </div>

        <div class="video-container" id="simulationVideo">
            <video id="simulationPlayer" loop>
                <source src="" type="video/webm">
                Your browser does not support the video tag.
            </video>
            <div class="video-controls">
                <button class="video-control-btn" id="playPauseBtn">▶️</button>
                <button class="video-control-btn" id="fullscreenBtn">⛶</button>
            </div>
            <button class="download-btn" id="downloadBtn">
                <span>⬇️</span>
                <span>Download</span>
            </button>
        </div>
    </div>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text">Generating Simulation</div>
            <div class="loading-subtext" id="loadingSubtext">This may take a few minutes...</div>
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
        $(document).ready(function() {
            const $inputMethods = $('.input-method-card');
            const $inputSections = $('.input-section');
            const $startBtn = $('#startSimulationBtn');
            const $loadingOverlay = $('#loadingOverlay');
            const $videoContainer = $('#simulationVideo');
            const $video = $('#simulationPlayer');
            const $playPauseBtn = $('#playPauseBtn');
            const $fullscreenBtn = $('#fullscreenBtn');
            const $taskChips = $('.task-suggestion-chip');
            const $customTokenInput = $('#customTokenInput');
            const $figmaAccessToken = $('#figmaAccessToken');

            // Set Figma File as default
            $('.input-method-card[data-method="figma"]').addClass('active');
            $('#figmaInput').show();
            $inputSections.not('#figmaInput').hide();

            // Handle input method selection
            $inputMethods.on('click', function() {
                const method = $(this).data('method');
                $inputMethods.removeClass('active');
                $(this).addClass('active');
                $inputSections.hide();
                $(`#${method}Input`).show();
            });

            // Handle task suggestion chips
            $taskChips.on('click', function() {
                const task = $(this).text();
                $('#taskDescription').val(task);
            });

            // Handle file upload
            $('#designFile').on('change', function(e) {
                const fileName = e.target.files[0]?.name;
                if (fileName) {
                    $(this).next('.file-upload-label').find('span:last').text(fileName);
                }
            });

            // Handle token selection
            $figmaAccessToken.on('change', function() {
                if ($(this).val() === 'custom') {
                    $customTokenInput.show();
                } else {
                    $customTokenInput.hide();
                }
            });

            // Helper function to get the selected token
            function getSelectedToken() {
                const selectedValue = $figmaAccessToken.val();
                if (selectedValue === 'custom') {
                    return $('#customFigmaToken').val();
                }
                return selectedValue;
            }

            // Add token validation before any Figma-related operations
            function validateToken() {
                const token = getSelectedToken();
                if (!token) {
                    alert("Please select or enter a Figma access token");
                    return false;
                }
                return true;
            }

            // Handle simulation start
            $startBtn.on('click', async function() {
                const activeMethod = $('.input-method-card.active').data('method');
                const taskDescription = $('#taskDescription').val();

                if (!taskDescription) {
                    alert('Please provide a task description');
                    return;
                }

                let designData = null;
                switch (activeMethod) {
                    case 'figma':
                        if (!validateToken()) return;
                        const figmaId = $('#figmaFileId').val();
                        if (!figmaId) {
                            alert('Please enter a Figma file ID');
                            return;
                        }
                        designData = { type: 'figma', id: figmaId };
                        break;
                    case 'upload':
                        const file = $('#designFile')[0].files[0];
                        if (!file) {
                            alert('Please upload a design file');
                            return;
                        }
                        designData = { type: 'file', file: file };
                        break;
                    case 'url':
                        const url = $('#designUrl').val();
                        if (!url) {
                            alert('Please enter a design URL');
                            return;
                        }
                        designData = { type: 'url', url: url };
                        break;
                }

                $loadingOverlay.addClass('active');
                $startBtn.prop('disabled', true);

                try {
                    console.log("Sending request to generate simulation...");
                    const response = await $.ajax({
                        url: '/ux/generate_simulation/',
                        method: 'POST',
                        data: JSON.stringify({
                            design_data: designData,
                            task_description: taskDescription,
                            access_token: getSelectedToken()
                        }),
                        contentType: 'application/json'
                    });
                    
                    console.log("Response received:", response);
                    
                    if (response.simulation_data) {
                        console.log("Simulation data received:", response.simulation_data);
                        
                        if (!response.simulation_data.steps || !Array.isArray(response.simulation_data.steps)) {
                            throw new Error('Invalid simulation data format: missing or invalid steps array');
                        }
                        
                        // Create video from simulation data
                        await createAndDownloadVideo(response.simulation_data);
                    } else {
                        throw new Error('No simulation data returned');
                    }
                } catch (error) {
                    console.error("Error in simulation generation:", error);
                    alert('Failed to generate simulation: ' + (error.message || 'Unknown error'));
                } finally {
                    $loadingOverlay.removeClass('active');
                    $startBtn.prop('disabled', false);
                }
            });

            // Video controls
            $playPauseBtn.on('click', function() {
                if ($video[0].paused) {
                    $video[0].play();
                    $(this).text('⏸️');
                } else {
                    $video[0].pause();
                    $(this).text('▶️');
                }
            });

            $fullscreenBtn.on('click', function() {
                if ($videoContainer[0].requestFullscreen) {
                    $videoContainer[0].requestFullscreen();
                } else if ($videoContainer[0].webkitRequestFullscreen) {
                    $videoContainer[0].webkitRequestFullscreen();
                } else if ($videoContainer[0].msRequestFullscreen) {
                    $videoContainer[0].msRequestFullscreen();
                }
            });

            // Video events
            $video.on('play', function() {
                $playPauseBtn.text('⏸️');
            });

            $video.on('pause', function() {
                $playPauseBtn.text('▶️');
            });
        });

        async function createAndDownloadVideo(simulationData) {
            try {
                console.log("Starting video creation...");
                const loadingOverlay = document.getElementById('loadingOverlay');
                const loadingSubtext = document.getElementById('loadingSubtext');
                const loadingProgress = document.getElementById('loadingProgress');
                
                loadingOverlay.classList.add('active');
                loadingSubtext.textContent = 'Initializing video generation...';
                
                // Create canvas with higher resolution
                const canvas = document.createElement('canvas');
                const width = 750;  // 2x resolution
                const height = 1334; // 2x resolution
                canvas.width = width;
                canvas.height = height;
                canvas.style.display = 'none';
                document.body.appendChild(canvas);
              
                const ctx = canvas.getContext('2d');
                
                // Prepare to record canvas stream with higher quality
                const stream = canvas.captureStream(30); // 30 FPS for smoother video
                let chunks = [];
                
                // Try different codecs in order of preference
                const codecs = [
                    'video/webm;codecs=vp9',
                    'video/webm;codecs=vp8',
                    'video/webm'
                ];
                
                let mediaRecorder;
                for (const codec of codecs) {
                    try {
                        mediaRecorder = new MediaRecorder(stream, {
                            mimeType: codec,
                            videoBitsPerSecond: 5000000 // 5 Mbps for high quality
                        });
                        console.log("Using codec:", codec);
                        break;
                    } catch (e) {
                        console.log("Codec not supported:", codec);
                        continue;
                    }
                }
                
                if (!mediaRecorder) {
                    throw new Error("No supported video codec found");
                }
                
                mediaRecorder.ondataavailable = e => chunks.push(e.data);
                mediaRecorder.start();
                loadingSubtext.textContent = 'Starting video recording...';

                // Helper to load image with retry
                async function loadImage(src, maxRetries = 3) {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        let retryCount = 0;
                        const timeout = 30000; // 30 seconds timeout
                        let timeoutId;

                        function tryLoad() {
                            if (timeoutId) clearTimeout(timeoutId);
                            
                            // Use the manipulated_image directly if it's a base64 string
                            const imageUrl = src.startsWith('data:image') ? src : STATIC_URL + src;
                            
                            timeoutId = setTimeout(() => {
                                if (retryCount < maxRetries) {
                                    retryCount++;
                                    console.log(`Retrying image load (${retryCount}/${maxRetries})...`);
                                    setTimeout(tryLoad, 2000); // Wait 2 seconds between retries
                                } else {
                                    reject(new Error(`Failed to load image after ${maxRetries} attempts: Image load timeout`));
                                }
                            }, timeout);

                            img.onload = () => {
                                clearTimeout(timeoutId);
                                resolve(img);
                            };

                            img.onerror = (e) => {
                                clearTimeout(timeoutId);
                                if (retryCount < maxRetries) {
                                    retryCount++;
                                    console.log(`Error loading image, retrying (${retryCount}/${maxRetries})...`);
                                    setTimeout(tryLoad, 2000);
                                } else {
                                    reject(new Error(`Failed to load image after ${maxRetries} attempts: ${e.message}`));
                                }
                            };

                            img.src = imageUrl;
                        }

                        tryLoad();
                    });
                }

                // Helper to draw cursor with smooth movement
                function drawCursor(ctx, cursor, progress, width, height) {
                    if (!cursor) return;
                    
                    const x = (cursor.x / 100) * width;
                    const y = (cursor.y / 100) * height;
                    
                    // Draw cursor shadow
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 15;
                    ctx.shadowOffsetY = 3;
                    
                    // Draw cursor with smooth movement
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + 15, y + 25);
                    ctx.lineTo(x + 5, y + 20);
                    ctx.closePath();
                    ctx.fillStyle = 'white';
                    ctx.fill();
                    
                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetY = 0;
                    
                    // Draw click effect if action is click
                    if (cursor.action === 'click' && progress > 0.8) {
                        // Draw large red dot
                        ctx.beginPath();
                        ctx.arc(x, y, 15, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                        ctx.fill();
                        
                        // Draw white border around red dot
                        ctx.beginPath();
                        ctx.arc(x, y, 15, 0, Math.PI * 2);
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                        
                        // Draw ripple effect
                        const rippleProgress = (progress - 0.8) * 5; // Scale to 0-1
                        const maxRadius = 40;
                        const radius = maxRadius * rippleProgress;
                        
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgba(255, 0, 0, ${1 - rippleProgress})`;
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                }

                // Helper to draw text input animation with typing effect
                function drawTextInput(ctx, animation, progress, width, height) {
                    if (!animation || animation.type !== 'type') return;
                    
                    const [x, y] = animation.target.split(',').map(Number);
                    const text = animation.text || '';
                    const visibleLength = Math.floor(text.length * progress);
                    const visibleText = text.substring(0, visibleLength);
                    
                    // Draw input field background with highlight
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.fillRect(x, y, 200, 30);
                    
                    // Draw input field border
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, 200, 30);
                    
                    // Draw text with typing animation
                    ctx.fillStyle = 'white';
                    ctx.font = '16px Inter, sans-serif';
                    ctx.fillText(visibleText, x + 10, y + 20);
                    
                    // Draw blinking cursor if still typing
                    if (progress < 1) {
                        const textWidth = ctx.measureText(visibleText).width;
                        const cursorOpacity = Math.sin(Date.now() / 200) * 0.5 + 0.5; // Blinking effect
                        ctx.fillStyle = `rgba(255, 255, 255, ${cursorOpacity})`;
                        ctx.fillRect(x + 10 + textWidth, y + 5, 2, 20);
                    }
                }

                // Helper to draw animations with enhanced effects
                function drawAnimations(ctx, animations, progress, width, height) {
                    if (!animations) return;
                    
                    animations.forEach(animation => {
                        switch (animation.type) {
                            case 'fade':
                                // Draw fade effect
                                const fadeOpacity = Math.min(1, progress * 2);
                                ctx.fillStyle = `rgba(255, 255, 255, ${fadeOpacity * 0.2})`;
                                ctx.fillRect(0, 0, width, height);
                                break;
                                
                            case 'slide':
                                // Draw slide effect
                                const slideProgress = Math.min(1, progress * 2);
                                const slideOffset = width * (1 - slideProgress);
                                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                                ctx.fillRect(slideOffset, 0, width, height);
                                break;
                                
                            case 'type':
                                drawTextInput(ctx, animation, progress, width, height);
                                break;
                        }
                    });
                }

                // Helper to draw overlay text with proper positioning
                function drawActionText(ctx, text, progress, width, height) {
                    if (!text) return;
                    
                    const padding = 40;
                    const textHeight = 80;
                    const y = height - padding - textHeight;
                    
                    // Draw gradient background
                    const gradient = ctx.createLinearGradient(0, y, 0, height);
                    gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0.8)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, y, width, textHeight + padding);

                    // Draw action text with animation
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 32px Inter, sans-serif';
                    ctx.textAlign = 'center';
                    
                    // Split text into lines
                    const words = text.split(' ');
                    const lines = [];
                    let currentLine = words[0];
                    
                    for (let i = 1; i < words.length; i++) {
                        const word = words[i];
                        const width = ctx.measureText(currentLine + " " + word).width;
                        if (width < width - 100) {
                            currentLine += " " + word;
                        } else {
                            lines.push(currentLine);
                            currentLine = word;
                        }
                    }
                    lines.push(currentLine);

                    // Draw each line with animation
                    lines.forEach((line, index) => {
                        const opacity = Math.min(1, progress * 2 - (index * 0.2));
                        if (opacity > 0) {
                            ctx.globalAlpha = opacity;
                            ctx.fillText(line, width/2, y + 40 + (index * 40));
                        }
                    });
                    ctx.globalAlpha = 1;
                }

                // Helper to draw progress indicator
                function drawProgressIndicator(ctx, currentStep, totalSteps, width) {
                    const padding = 20;
                    const height = 4;
                    const y = 20;
                    
                    // Draw background
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.fillRect(padding, y, width - (padding * 2), height);
                    
                    // Draw progress
                    const progress = (currentStep + 1) / totalSteps;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(padding, y, (width - (padding * 2)) * progress, height);
                }

                const totalSteps = simulationData.steps.length;
                for (let stepIndex = 0; stepIndex < totalSteps; stepIndex++) {
                    const step = simulationData.steps[stepIndex];
                    try {
                        console.log("Processing step:", step);
                        loadingSubtext.textContent = `Processing frame ${stepIndex + 1} of ${totalSteps}`;
                        loadingProgress.textContent = `Step ${stepIndex + 1}: ${step.action}`;
                        
                        // Use manipulated_image directly instead of frame_url
                        const img = await loadImage(step.manipulated_image);
                        
                        const durationMs = step.duration * 1000;
                        const frameCount = Math.round(30 * step.duration); // 30 FPS
                        
                        console.log(`Generating ${frameCount} frames for step`);
                        loadingSubtext.textContent = `Generating ${frameCount} frames for step ${stepIndex + 1}`;
                        
                        // Update the frame generation loop to use manipulated images
                        for (let i = 0; i < frameCount; i++) {
                            ctx.clearRect(0, 0, width, height);
                            
                            // Draw the manipulated image
                            const progress = i / frameCount;
                            ctx.globalAlpha = 1;
                            ctx.drawImage(img, 0, 0, width, height);
                            
                            // Draw progress indicator
                            drawProgressIndicator(ctx, stepIndex, totalSteps, width);
                            
                            // Draw action text with animation
                            drawActionText(ctx, step.overlay_text, progress, width, height);
                            
                            // Update progress
                            if (i % 10 === 0) {
                                loadingProgress.textContent = `Step ${stepIndex + 1}: ${step.action} (${Math.round(progress * 100)}%)`;
                            }
                            
                            await new Promise(r => setTimeout(r, 1000 / 30));
                        }
                    } catch (error) {
                        console.error(`Error processing step:`, error);
                        throw error;
                    }
                }
              
                console.log("All frames generated, stopping recording...");
                loadingSubtext.textContent = 'Finalizing video...';
                mediaRecorder.stop();
              
                // Wait for recording to finish and assemble blob
                const videoBlob = await new Promise(resolve => {
                    mediaRecorder.onstop = e => {
                        console.log("Recording stopped, creating blob...");
                        const blob = new Blob(chunks, {type: 'video/webm'});
                        resolve(blob);
                    };
                });
              
                // Remove canvas from DOM
                canvas.remove();
              
                console.log("Creating video element...");
                // Create video element and play it
                const videoContainer = document.getElementById('simulationVideo');
                const video = document.getElementById('simulationPlayer');
                const downloadBtn = document.getElementById('downloadBtn');
                
                // Create blob URL for the video
                const videoBlobUrl = URL.createObjectURL(videoBlob);
                video.src = videoBlobUrl;
                videoContainer.classList.add('active');
                
                // Set up download button
                downloadBtn.onclick = () => {
                    const a = document.createElement('a');
                    a.href = videoBlobUrl;
                    a.download = 'simulation.webm';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                };
                
                // Wait for video to be ready before playing
                video.onloadeddata = () => {
                    video.play().catch(e => {
                        console.error("Error playing video:", e);
                        alert("Click the play button to start the video");
                    });
                };
                
                console.log("Video generation completed successfully");
            } catch (error) {
                console.error('Error creating video:', error);
                throw error; // Re-throw to be caught by the outer try-catch
            } finally {
                // Hide loading state
                const loadingOverlay = document.getElementById('loadingOverlay');
                loadingOverlay.classList.remove('active');
            }
        }
    </script>
</body>
</html> 