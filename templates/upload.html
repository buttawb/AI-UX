<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>UX Analysis - UX Tester</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/styles.css">
    <link rel="stylesheet" href="/static/css/particles.css">
    <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="/static/js/particles-config.js"></script>
    <style>
        .visualization-controls {
            position: relative;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .nav-buttons {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            justify-content: center;
        }

        .nav-button {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
        }

        .nav-button:hover {
            transform: translateY(-2px);
            border-color: var(--primary);
            box-shadow: var(--shadow);
        }

        .nav-button.active {
            background: linear-gradient(135deg, var(--primary), #4f46e5);
            color: white;
            border-color: transparent;
        }

        .nav-button .icon {
            font-size: 1.2rem;
        }

        .nav-button .badge {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.8rem;
            margin-left: 0.5rem;
        }

        .nav-button:not(.active) .badge {
            background: var(--background);
            color: var(--primary);
        }

        .viz-controls-wrapper {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            width: 100%;
        }

        .viz-toggle-container {
            position: relative;
            display: flex;
            align-items: center;
            width: 100%;
        }

        .viz-toggle-container::before {
            display: none !important;
        }

        .viz-toggle-checkbox {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
            pointer-events: none;
            visibility: hidden;
        }

        .viz-toggle-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: #fff;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            width: 100%;
            text-align: center;
        }

        .viz-toggle-btn::before {
            display: none !important;
        }

        .viz-toggle-btn:hover {
            background: #f8fafc;
        }

        .viz-toggle-btn .viz-icon {
            font-size: 1.1em;
        }

        .viz-toggle-checkbox:checked + .viz-toggle-btn {
            background: #f1f5f9;
            border-color: #cbd5e1;
        }

        .viz-toggle-checkbox:checked + .viz-toggle-btn.heatmap-btn {
            background: linear-gradient(135deg, #ff9800, #ff5722);
            color: white;
            border-color: #e64a19;
        }

        .viz-toggle-checkbox:checked + .viz-toggle-btn.reach-btn {
            background: linear-gradient(135deg, #03a9f4, #2196f3);
            color: white;
            border-color: #1976d2;
        }

        .viz-toggle-checkbox:checked + .viz-toggle-btn.suggestions-btn {
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border-color: #1B5E20;
        }

        .viz-toggle-checkbox:checked + .viz-toggle-btn.dropoffs-btn {
            background: linear-gradient(135deg, #F44336, #D32F2F);
            color: white;
            border-color: #B71C1C;
        }

        .viz-toggle-checkbox:checked + .viz-toggle-btn.positives-btn {
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border-color: #1B5E20;
        }

        .viz-toggle-checkbox:checked + .viz-toggle-btn.enhance-btn {
            background: linear-gradient(135deg, #8b5cf6, #6d28d9);
            color: white;
            border-color: #5b21b6;
        }

        .heatmap-layer,
        .reach-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            border-radius: var(--radius);
            overflow: hidden;
            display: none;
            transition: opacity 0.3s ease;
        }

        .heatmap-layer.active,
        .reach-layer.active {
            display: block;
        }

        .ux-suggestion-marker,
        .ux-dropoff-marker {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: none;
            cursor: pointer;
            z-index: 10;
        }

        .ux-suggestion-marker {
            background: rgba(76, 175, 80, 0.9);
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .ux-dropoff-marker {
            background: rgba(244, 67, 54, 0.9);
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .ux-suggestion-marker span,
        .ux-dropoff-marker span {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: 600;
            line-height: 1;
            text-align: center;
            width: 100%;
        }

        .ux-dropoff-marker span {
            font-size: 14px;
        }

        .ux-suggestion-marker.active,
        .ux-dropoff-marker.active {
            display: block;
        }

        .design-visualization {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 1rem;
            align-items: start;
        }

        .heatmap-container {
            position: relative;
            border-radius: var(--radius);
            overflow: visible;
            background-color: var(--background);
            box-shadow: var(--shadow);
            width: 100%;
            flex: 1;
            min-height: 0;
        }

        .report-column {
            width: 45%;
            padding-left: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            height: 100%;
        }

        .analysis-content {
            display: flex;
            gap: 2rem;
            width: 100%;
            height: 100%;
            min-height: 600px;
        }

        .design-column {
            width: 55%;
            min-width: 0;
            display: flex;
            flex-direction: column;
        }

        .reach-legend {
            margin-top: 0;
            padding: 1.25rem;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: none;
            border-left: 4px solid #3b82f6;
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            flex-shrink: 0;
        }

        .reach-legend.active {
            display: block;
        }

        .reach-legend h4 {
            margin: 0 0 1rem 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: #2563eb;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #e2e8f0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .legend-item:hover {
            background: rgba(255, 255, 255, 0.8);
            transform: translateX(4px);
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .color-box.easy {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
        }

        .color-box.stretch {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }

        .color-box.hard {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }

        .legend-item span {
            font-size: 0.9rem;
            color: #1e293b;
            font-weight: 500;
        }

        .legend-item .description {
            font-size: 0.8rem;
            color: #64748b;
            margin-top: 0.25rem;
        }

        .ux-positive-marker {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: none;
            cursor: pointer;
            z-index: 10;
            background: rgba(99, 102, 241, 0.9);
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .ux-positive-marker span {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            font-weight: 600;
            line-height: 1;
            text-align: center;
            width: 100%;
        }

        .ux-positive-marker.active {
            display: block;
        }

        .ux-report {
            background: #fff;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 1.5rem;
            font-size: 0.95rem;
            line-height: 1.6;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            max-height: none;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Inter', sans-serif;
        }

        .ux-report pre {
            display: none;
        }

        .ux-report:hover pre {
            display: none;
        }

        .ux-report h2 {
            color: var(--primary);
            font-size: 1.25rem;
            font-weight: 600;
            margin: 1.5rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--primary);
        }

        .ux-report h2:first-child {
            margin-top: 0;
        }

        .ux-report ul {
            list-style: none;
            padding: 0;
            margin: 0.75rem 0;
        }

        .ux-report li {
            position: relative;
            padding-left: 1.5rem;
            margin-bottom: 0.75rem;
        }

        .ux-report li:before {
            content: "•";
            position: absolute;
            left: 0;
            color: var(--primary);
            font-weight: bold;
        }

        .ux-report p {
            margin: 0.75rem 0;
            color: #4a5568;
        }

        .report-section {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: #f8fafc;
            border-radius: 8px;
            border-left: 4px solid var(--primary);
        }

        .report-section:last-child {
            margin-bottom: 0;
        }

        .report-section h2 {
            color: var(--primary);
            font-size: 1.1rem;
            margin: 0 0 0.75rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #e2e8f0;
        }

        .report-section ul {
            margin: 0;
            padding: 0;
        }

        .report-section li {
            margin-bottom: 0.5rem;
            padding-left: 1.25rem;
            position: relative;
        }

        .report-section li:before {
            content: "•";
            position: absolute;
            left: 0;
            color: var(--primary);
        }

        .report-section.overall {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
        }

        .report-section.strengths {
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            border-left-color: #22c55e;
        }

        .report-section.strengths h2 {
            color: #16a34a;
        }

        .report-section.improvements {
            background: linear-gradient(135deg, #fff7ed 0%, #ffedd5 100%);
            border-left-color: #f97316;
        }

        .report-section.improvements h2 {
            color: #ea580c;
        }

        .report-section.recommendations {
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            border-left-color: #3b82f6;
        }

        .report-section.recommendations h2 {
            color: #2563eb;
        }

        .positive-popup {
            position: absolute;
            background: white;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            max-width: 300px;
            display: none;
        }

        .positive-popup.active {
            display: block;
        }

        .positive-popup h3 {
            color: #6366f1;
            margin: 0 0 0.5rem 0;
            font-size: 1rem;
            font-weight: 600;
        }

        .positive-popup p {
            margin: 0;
            color: #4b5563;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .viz-toggle-checkbox:checked + .viz-toggle-btn.positives-btn {
            background: linear-gradient(135deg, #6366f1, #4f46e5);
            color: white;
            border-color: #4338ca;
        }

        .input-method-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .input-method-card {
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .input-method-card:hover {
            transform: translateY(-2px);
            border-color: var(--primary);
            box-shadow: var(--shadow);
        }

        .input-method-card.active {
            border-color: var(--primary);
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.05), rgba(79, 70, 229, 0.05));
        }

        .input-method-card .icon {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: var(--primary);
        }

        .input-method-card h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

        .input-method-card p {
            font-size: 0.9rem;
            color: var(--text-light);
            margin: 0;
        }

        .file-upload-container {
            position: relative;
            margin-top: 1rem;
        }

        .file-upload-input {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            opacity: 0;
            cursor: pointer;
        }

        .file-upload-label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 1rem;
            background: var(--background);
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            color: var(--text-light);
            transition: all 0.2s ease;
        }

        .file-upload-label:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .file-upload-label .icon {
            font-size: 1.5rem;
        }

        .ux-score-container {
            position: relative;
            z-index: 20;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: linear-gradient(135deg, var(--primary), #4f46e5);
            color: white;
            border-radius: var(--radius);
            font-weight: 500;
            box-shadow: var(--shadow);
        }

        .ux-score-container.poor {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }

        .ux-score-container .ux-score-value {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .enhancement-sticker {
            position: absolute;
            top: -0.75rem;
            left: -0.75rem;
            background: linear-gradient(135deg, #8b5cf6, #6d28d9);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 500;
            text-decoration: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            transition: all 0.3s ease;
            border: 2px solid white;
        }

        .enhancement-sticker:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
            color: white;
        }

        .enhancement-sticker .icon {
            font-size: 1rem;
        }

        .enhancement-sticker .badge {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.15rem 0.35rem;
            border-radius: 8px;
            font-size: 0.7rem;
        }

        .frame-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .heatmap-container {
            position: relative;
            border-radius: var(--radius);
            overflow: hidden;
            background-color: var(--background);
            box-shadow: var(--shadow);
            width: 100%;
            flex: 1;
            min-height: 0;
        }

        .enhance-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: linear-gradient(135deg, #8b5cf6, #6d28d9);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            width: 100%;
            text-align: center;
        }

        .enhance-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        #submitBtn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            padding: 0.875rem 1.75rem;
            background: linear-gradient(135deg, var(--primary), #4f46e5);
            color: white;
            border: none;
            border-radius: var(--radius);
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            min-width: 160px;
            width: 100%;
            margin-top: 1.5rem;
        }

        #submitBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.2);
        }

        #submitBtn:active {
            transform: translateY(0);
        }

        #submitBtn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }

        #submitBtn.loading {
            background: linear-gradient(135deg, #4f46e5, #4f46e5);
            cursor: wait;
        }

        #submitBtn.loading::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: button-spin 0.8s linear infinite;
        }

        @keyframes button-spin {
            to { transform: rotate(360deg); }
        }

        #submitBtn.loading span {
            visibility: hidden;
        }
    </style>
</head>
<body>
    <div id="particles-js"></div>
    <div class="container">
        <div class="header">
            <div class="main-title">
                <h1 class="gradient-text">AI-UX</h1>
            </div>
            <div class="sub-title">
                <h2>UX Analysis</h2>
                <p>Transform your Figma designs into actionable UX insights with AI-powered analysis</p>
            </div>
        </div>

        <div class="nav-buttons">
            <a href="/upload_design/" class="nav-button active">
                <span class="icon">📊</span>
                <span>UX Analysis</span>
                {% comment %} <span class="badge">Heatmap</span> {% endcomment %}
            </a>
            <a href="/simulation/" class="nav-button">
                <span class="icon">🎬</span>
                <span>User Journey</span>
                <span class="badge">New!</span>
            </a>
            <a href="/design_iteration/" class="nav-button">
                <span class="icon">🔄</span>
                <span>Design Iteration</span>
                <span class="badge">New!</span>
            </a>
        </div>

        <div id="controls">
            <div class="form-group">
                <label for="figmaAccessToken">Figma Access Token</label>
                <select id="figmaAccessToken" class="form-control">
                    <option value="">Select a token or enter custom...</option>
                    <option value="wahab_token">Wahab's Token</option>
                    <option value="ramsha_token">Ramsha's Token</option>
                    <option value="farzam_token">Farzam's Token</option>
                    <option value="custom">Enter Custom Token</option>
                </select>
                <div id="customTokenInput" style="display: none; margin-top: 0.5rem;">
                    <input type="text" id="customFigmaToken" class="form-control" placeholder="Enter your custom Figma access token">
                </div>
                <small class="form-text">Select a predefined token or enter your own Figma access token</small>
            </div>

            <div class="input-method-selector">
                <div class="input-method-card" data-method="figma">
                    <div class="icon">🎨</div>
                    <h3>Figma File</h3>
                    <p>Enter your Figma file ID to analyze</p>
                </div>
                <div class="input-method-card" data-method="upload">
                    <div class="icon">📁</div>
                    <h3>Upload Design</h3>
                    <p>Upload your design file directly</p>
                </div>
                <div class="input-method-card" data-method="url">
                    <div class="icon">🔗</div>
                    <h3>Design URL</h3>
                    <p>Provide a URL to your design</p>
                </div>
            </div>

            <div id="figmaInput" class="input-section">
                <div class="form-group">
                    <label for="figmaFileId">Figma File ID</label>
                    <input type="text" id="figmaFileId" value="{{ figma_file_id }}" class="form-control" placeholder="Enter your Figma file ID">
                    <small class="form-text">The unique identifier of your Figma file to analyze</small>
                </div>
            </div>

            <div id="uploadInput" class="input-section" style="display: none;">
                <div class="form-group">
                    <label>Upload Design File</label>
                    <div class="file-upload-container">
                        <input type="file" id="designFile" class="file-upload-input" accept=".fig,.sketch,.xd">
                        <label for="designFile" class="file-upload-label">
                            <span class="icon">📁</span>
                            <span>Click to upload or drag and drop</span>
                        </label>
                    </div>
                    <small class="form-text">Supported formats: Figma (.fig)</small>
                </div>
            </div>

            <div id="urlInput" class="input-section" style="display: none;">
                <div class="form-group">
                    <label for="designUrl">Design URL</label>
                    <input type="url" id="designUrl" class="form-control" placeholder="Enter the URL to your design">
                    <small class="form-text">Provide a direct link to your design file</small>
                </div>
            </div>

            <div class="form-group">
                <label for="userPrompt">Custom Analysis Instructions</label>
                <textarea id="userPrompt" class="form-control" rows="4" placeholder="Add specific instructions for the analysis (e.g., focus on mobile responsiveness, accessibility, or specific user flows)"></textarea>
                <small class="form-text">Your instructions will guide the analysis while maintaining the required output structure</small>
            </div>
            <button id="submitBtn">Start Analysis</button>
        </div>

        <div id="loader">
            <div class="spinner"></div>
            <p class="loading-text" id="loadingText">Analyzing your design... This may take a few minutes</p>
        </div>

        <div id="analysisContainer"></div>
    </div>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/heatmap.js/2.0.2/heatmap.min.js"></script>
    
    <script>
      // Check if heatmap.js is loaded correctly
      document.addEventListener('DOMContentLoaded', function() {
          console.log('DOM loaded, checking heatmap.js availability');
          if (typeof h337 === 'undefined') {
              console.error('ERROR: heatmap.js (h337) is not loaded properly!');
          } else {
              console.log('heatmap.js is loaded correctly:', h337);
          }
      });
    </script>
    
    <script>
      $(document).ready(function() {
          const $inputMethods = $('.input-method-card');
          const $inputSections = $('.input-section');
          const $submitBtn = $('#submitBtn');
          const $loader = $('#loader');
          const $analysisContainer = $('#analysisContainer');
          const $loadingText = $('#loadingText');
          const $customTokenInput = $('#customTokenInput');
          const $figmaAccessToken = $('#figmaAccessToken');

          // Set Figma File as default - more explicit initialization
          function initializeDefaultInput() {
              // Remove active class from all methods
              $inputMethods.removeClass('active');
              // Hide all input sections
              $inputSections.hide();
              
              // Set Figma as active
              $('.input-method-card[data-method="figma"]').addClass('active');
              // Show Figma input section
              $('#figmaInput').show();
          }

          // Call initialization on page load
          initializeDefaultInput();

          // Handle input method selection
          $inputMethods.on('click', function() {
              const method = $(this).data('method');
              $inputMethods.removeClass('active');
              $(this).addClass('active');
              $inputSections.hide();
              $(`#${method}Input`).show();
          });

          // Handle token selection
          $figmaAccessToken.on('change', function() {
              if ($(this).val() === 'custom') {
                  $customTokenInput.show();
              } else {
                  $customTokenInput.hide();
              }
          });

          // Helper function to get the selected token
          function getSelectedToken() {
              const selectedValue = $figmaAccessToken.val();
              if (selectedValue === 'custom') {
                  return $('#customFigmaToken').val();
              }
              return selectedValue;
          }

          // Helper function to ensure minimum display time for loading messages
          async function updateLoadingText(text, minDisplayTime = 1500) {
              const startTime = Date.now();
              $loadingText.text(text);
              
              // Wait for the minimum display time
              const elapsedTime = Date.now() - startTime;
              if (elapsedTime < minDisplayTime) {
                  await new Promise(resolve => setTimeout(resolve, minDisplayTime - elapsedTime));
              }
          }
  
          $submitBtn.on('click', async function() {
              const activeMethod = $('.input-method-card.active').data('method');
              const userPrompt = $('#userPrompt').val();
              const figmaToken = getSelectedToken();

              if (!figmaToken) {
                  alert("Please select or enter a Figma access token");
                  return;
              }

              let designData = null;
              switch (activeMethod) {
                  case 'figma':
                      const figmaId = $('#figmaFileId').val();
                      if (!figmaId) {
                          alert('Please enter a Figma file ID');
                          return;
                      }
                      designData = { type: 'figma', id: figmaId };
                      break;
                  case 'upload':
                      const file = $('#designFile')[0].files[0];
                      if (!file) {
                          alert('Please upload a design file');
                          return;
                      }
                      designData = { type: 'file', file: file };
                      break;
                  case 'url':
                      const url = $('#designUrl').val();
                      if (!url) {
                          alert('Please enter a design URL');
                          return;
                      }
                      designData = { type: 'url', url: url };
                      break;
              }

              $submitBtn.prop('disabled', true);
              $loader.show();
              $analysisContainer.empty().hide();

              try {
                  // 1. Fetch the entire Figma file structure
                  console.log("Fetching Figma file structure...");
                  await updateLoadingText('Fetching Figma file structure...');
                  const figmaFileId = $('#figmaFileId').val();
                  const figmaToken = getSelectedToken();
                  
                  if (!figmaToken) {
                      throw new Error("Please select or enter a Figma access token");
                  }
                  
                  const figmaFileResponse = await $.ajax({
                      url: '/fetch_figma_file/',
                      type: 'GET',
                      data: { 
                          file_id: figmaFileId,
                          access_token: figmaToken
                      }
                  });
                  console.log("Figma file fetched.", figmaFileResponse);
  
                  // 2. Extract all top-level frames from the document
                  const frames = [];
                  figmaFileResponse.document.children.forEach(canvas => {
                      if (canvas.children) {
                          canvas.children.forEach(frame => {
                              if (frame.type === 'FRAME') {
                                  frames.push({
                                      id: frame.id,
                                      name: frame.name,
                                      node: frame
                                  });
                              }
                          });
                      }
                  });
  
                  if (frames.length === 0) {
                      throw new Error("No frames found in the Figma file.");
                  }
                  console.log(`Found ${frames.length} frames to analyze.`);
                  await updateLoadingText(`Found ${frames.length} frames to analyze...`);
                  const frameIds = frames.map(f => f.id);
  
                  // 3. Make parallel API calls
                  console.log("Fetching image URLs and running AI analysis in parallel...");
                  await updateLoadingText('Fetching image URLs and preparing for AI analysis...');
                  const [imageResponse, analysisResponse] = await Promise.all([
                      $.ajax({
                          url: '/fetch_figma_image_urls/',
                          type: 'POST',
                          contentType: 'application/json',
                          data: JSON.stringify({ 
                              node_ids: frameIds,
                              file_id: figmaFileId,
                              access_token: figmaToken
                          }),
                      }),
                      $.ajax({
                          url: '/generate_heatmap/',
                          type: 'POST',
                          contentType: 'application/json',
                          data: JSON.stringify({ 
                              figma_data: figmaFileResponse.document,
                              user_prompt: userPrompt 
                          }),
                      })
                  ]);
                  let heatmapData = analysisResponse.heatmap_data;
                  let analysisData;

                  await updateLoadingText('Processing AI analysis results...');
                  // *** DEBUGGING & FIX: Add robust checks and clear logging ***
                  console.log("Raw image response from server:", imageResponse);
                  console.log("Raw analysis response from server:", heatmapData);
  
                  if (!imageResponse || !imageResponse.image_urls) {
                      throw new Error("The server response for images was invalid or missing the 'image_urls' key.");
                  }
                  const imageUrls = imageResponse.image_urls;
  
                  if (heatmapData && !heatmapData.analysis_data) {
                      analysisData = heatmapData;
                      throw new Error("The server response for AI analysis was invalid or missing the 'analysis_data' key.");
                  }
                  else {
                    analysisData = heatmapData.analysis_data;
                  }
                  console.log("Data received and validated. Rendering results...");
                  await updateLoadingText('Rendering analysis results...');
                  $loader.hide();
  
                  // 4. Render results for each frame
                  frames.forEach(frame => {
                      const imageUrl = imageUrls[frame.id];
                      const frameAnalysis = analysisData[frame.id];
  
                      if (!imageUrl || !frameAnalysis) {
                          console.warn(`Skipping frame "${frame.name}" (${frame.id}) due to missing image URL or analysis data for this specific frame.`);
                          return; // Safely skip this frame
                      }

                      // Store frame analysis data globally
                      if (!window.frameAnalysisData) {
                          window.frameAnalysisData = {};
                      }
                      window.frameAnalysisData[frame.id] = frameAnalysis;

                      // Create the HTML structure for this frame
                      const safeId = frame.id.replace(/:/g, '-');
                      const uxScore = frameAnalysis.ux_score || 0;
                      
                      // Determine score category and emoji
                      let scoreClass = 'poor';
                      let scoreEmoji = '😢';
                      if (uxScore >= 90) {
                          scoreClass = 'excellent';
                          scoreEmoji = '🌟';
                      } else if (uxScore >= 75) {
                          scoreClass = 'good';
                          scoreEmoji = '👍';
                      } else if (uxScore >= 60) {
                          scoreClass = 'fair';
                          scoreEmoji = '🤔';
                      }
                      
                      const frameHtml = `
                          <div class="frame-container" id="frame-container-${safeId}">
                              <div class="frame-header">
                                  <span>${frame.name}</span>
                                  <div class="ux-score-container ${scoreClass}">
                                      <span>${scoreEmoji}</span>
                                      <span class="ux-score-value">${uxScore}</span>
                                      <span>UX Score</span>
                                  </div>
                              </div>
                              <div class="analysis-content">
                                  <div class="design-column">
                                      <div class="visualization-controls">
                                          <div class="viz-controls-wrapper">
                                              <label class="viz-toggle-container">
                                                  <input type="checkbox" class="viz-toggle-checkbox" data-target="heatmap" data-frame="${safeId}">
                                                  <span class="viz-toggle-btn heatmap-btn">
                                                      <span class="viz-icon">🔥</span>
                                                      <span class="viz-label">UX Heatmap</span>
                                                  </span>
                                              </label>
                                              <label class="viz-toggle-container">
                                                  <input type="checkbox" class="viz-toggle-checkbox" data-target="reach" data-frame="${safeId}">
                                                  <span class="viz-toggle-btn reach-btn">
                                                      <span class="viz-icon">👆</span>
                                                      <span class="viz-label">Finger Reach</span>
                                                  </span>
                                              </label>
                                              <label class="viz-toggle-container">
                                                  <input type="checkbox" class="viz-toggle-checkbox" data-target="suggestions" data-frame="${safeId}">
                                                  <span class="viz-toggle-btn suggestions-btn">
                                                      <span class="viz-icon">💡</span>
                                                      <span class="viz-label">Suggestions</span>
                                                  </span>
                                              </label>
                                              <label class="viz-toggle-container">
                                                  <input type="checkbox" class="viz-toggle-checkbox" data-target="dropoffs" data-frame="${safeId}">
                                                  <span class="viz-toggle-btn dropoffs-btn">
                                                      <span class="viz-icon">⚠️</span>
                                                      <span class="viz-label">Drop-offs</span>
                                                  </span>
                                              </label>
                                              <label class="viz-toggle-container">
                                                  <input type="checkbox" class="viz-toggle-checkbox" data-target="positives" data-frame="${safeId}">
                                                  <span class="viz-toggle-btn positives-btn">
                                                      <span class="viz-icon">✨</span>
                                                      <span class="viz-label">Positive Points</span>
                                                  </span>
                                              </label>
                                              <button class="enhance-btn" data-frame="${safeId}">
                                                  <span class="viz-icon">🎨</span>
                                                  <span class="viz-label">Enhance Design</span>
                                              </button>
                                          </div>
                                      </div>
                                      <div class="heatmap-container" id="heatmap-container-${safeId}">
                                          <img id="image-${safeId}" src="${imageUrl}" alt="Design for ${frame.name}" onerror="console.error('Image failed to load:', this.src)" />
                                          <div class="heatmap-layer" id="heatmap-layer-${safeId}"></div>
                                          <div class="reach-layer" id="reach-layer-${safeId}"></div>
                                      </div>
                                  </div>
                                  <div class="report-column">
                                      <h2>UX/UI Report</h2>
                                      <div class="ux-report" id="report-${safeId}">
                                          ${typeof frameAnalysis.report === 'string' ? frameAnalysis.report : JSON.stringify(frameAnalysis.report, null, 2)}
                                      </div>
                                      <div class="reach-legend" id="reach-legend-${safeId}">
                                          <h4>Thumb Reach Zones</h4>
                                          <div class="legend-item">
                                              <div class="color-box easy"></div>
                                              <div>
                                                  <span>Easy reach</span>
                                                  <div class="description">Comfortable thumb reach zone</div>
                                              </div>
                                          </div>
                                          <div class="legend-item">
                                              <div class="color-box stretch"></div>
                                              <div>
                                                  <span>Stretch reach</span>
                                                  <div class="description">Requires slight thumb stretch</div>
                                              </div>
                                          </div>
                                          <div class="legend-item">
                                              <div class="color-box hard"></div>
                                              <div>
                                                  <span>Hard reach</span>
                                                  <div class="description">Difficult to reach with thumb</div>
                                              </div>
                                          </div>
                                      </div>
                                  </div>
                              </div>
                          </div>
                      `;
                      $analysisContainer.append(frameHtml);
  
                      console.log(`Setting up image load handler for frame ${frame.id} with URL:`, imageUrl);
                      
                      // Wait for the image to load before rendering heatmap/suggestions
                      const $image = $(`#image-${safeId}`);
                      console.log(`Looking for image with ID: image-${safeId}`);
                      console.log('Image element found:', $image.length > 0);
                      
                      $image.on('load', function() {
                          console.log(`==== IMAGE LOAD EVENT - FRAME ${frame.id} ====`);
                          const $image = $(this);
                          const imgNaturalWidth = $image[0].naturalWidth;
                          const imgNaturalHeight = $image[0].naturalHeight;
                          console.log(`Image loaded for frame ${frame.id}:`, {
                              naturalWidth: imgNaturalWidth,
                              naturalHeight: imgNaturalHeight,
                              src: $image.attr('src')
                          });

                          // Get the container
                          console.log(`Getting heatmap container with ID: heatmap-container-${safeId}`);
                          const container = document.getElementById(`heatmap-container-${safeId}`);
                          if (!container) {
                              console.error(`ERROR: Container with ID heatmap-container-${safeId} not found!`);
                              return;
                          }
                          console.log('Container found:', container);
                          
                          // Verify heatmap layer exists
                          const heatmapLayer = container.querySelector('.heatmap-layer');
                          console.log('Heatmap layer element:', heatmapLayer);
                          
                          // Verify heatmap data
                          console.log('Heatmap data availability check:', {
                              hasFrameAnalysis: !!frameAnalysis,
                              hasHeatmapData: frameAnalysis && !!frameAnalysis.heatmap,
                              heatmapDataLength: frameAnalysis && frameAnalysis.heatmap ? frameAnalysis.heatmap.length : 0
                          });
                          
                          // Give time for the image to be fully rendered in the DOM
                          console.log('Setting timeout to ensure image is fully rendered...');
                          setTimeout(() => {
                              console.log('Timeout completed, proceeding with heatmap rendering');
                              const containerRect = container.getBoundingClientRect();
                              const containerWidth = containerRect.width;
                              const containerHeight = containerRect.height;
                              console.log('Container dimensions after image load:', { width: containerWidth, height: containerHeight });
                              
                              // Check if dimensions are valid
                              if (containerWidth <= 0 || containerHeight <= 0) {
                                  console.error('ERROR: Invalid container dimensions, cannot render heatmap');
                                  return;
                              }
                                                            
                              // Clear any existing content
                              if (heatmapLayer) {
                                  heatmapLayer.innerHTML = '';
                              }
                              
                              // Create a canvas element
                              const canvas = document.createElement('canvas');
                              canvas.width = containerWidth;
                              canvas.height = containerHeight;
                              canvas.style.position = 'absolute';
                              canvas.style.top = '0';
                              canvas.style.left = '0';
                              canvas.style.width = '100%';
                              canvas.style.height = '100%';
                              canvas.style.pointerEvents = 'none';
                              
                              // Add the canvas to the heatmap layer
                              heatmapLayer.appendChild(canvas);
                              
                              // Get the canvas context and draw the heatmap
                              const ctx = canvas.getContext('2d');
                              
                              // Create a gradient background for the heatmap
                              const gradient = ctx.createRadialGradient(
                                  containerWidth * 0.5, containerHeight * 0.4, 5,
                                  containerWidth * 0.5, containerHeight * 0.4, containerWidth * 0.5
                              );
                              gradient.addColorStop(0, 'rgba(255, 0, 0, 0.8)');
                              gradient.addColorStop(0.2, 'rgba(255, 255, 0, 0.6)');
                              gradient.addColorStop(0.4, 'rgba(0, 255, 255, 0.4)');
                              gradient.addColorStop(1, 'rgba(0, 0, 255, 0)');
                              
                              ctx.fillStyle = gradient;
                              ctx.fillRect(0, 0, containerWidth, containerHeight);
                              
                              // Add a few hotspot points
                              const drawHotspot = (x, y, radius, intensity) => {
                                  const gradient = ctx.createRadialGradient(
                                      x, y, 0,
                                      x, y, radius
                                  );
                                  gradient.addColorStop(0, `rgba(255, 0, 0, ${intensity})`);
                                  gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                                  
                                  ctx.fillStyle = gradient;
                                  ctx.beginPath();
                                  ctx.arc(x, y, radius, 0, Math.PI * 2);
                                  ctx.fill();
                              };
                              
                              // Draw sample hotspots in various locations
                            // Convert frameAnalysis.heatmap data to hotspots
                            if (frameAnalysis && frameAnalysis.heatmap && Array.isArray(frameAnalysis.heatmap)) {
                                frameAnalysis.heatmap.forEach(point => {
                                    // Convert percentage coordinates to pixels
                                    const x = (point.x / 100) * containerWidth;
                                    const y = (point.y / 100) * containerHeight;
                                    // Use point intensity or default to 0.7
                                    const intensity = point.intensity || 0.7;
                                    // Calculate radius based on intensity (30-60 pixels)
                                    const radius = 30 + (intensity * 30);
                                    drawHotspot(x, y, radius, intensity);
                                });
                            } 
                              
                              console.log('Canvas heatmap created successfully');
                              
                              // Skip the normal heatmap rendering
                              // renderHeatmap(frameAnalysis.heatmap, `heatmap-container-${safeId}`, containerWidth, containerHeight);
                              
                              console.log('Heatmap rendering complete, now rendering suggestions...');
                              renderSuggestions(frameAnalysis, this, `heatmap-container-${safeId}`, containerWidth, containerHeight);
                              console.log('Suggestions rendering complete');
                              console.log(`==== FRAME ${frame.id} RENDERING COMPLETE ====`);
                          }, 100);
                      }).on('error', function(e) {
                          console.error(`Error loading image for frame ${frame.id}:`, e);
                      }).each(function() {
                          console.log(`Checking if image ${frame.id} is already complete:`, this.complete);
                          if (this.complete) {
                              console.log(`Image ${frame.id} is already loaded, triggering load event`);
                              $(this).trigger('load');
                          }
                      });
                  });
                  
                  $analysisContainer.show();
  
              } catch (error) {
                  console.error('An error occurred during the analysis process:', error);
                  const errorMessage = error.responseJSON ? JSON.stringify(error.responseJSON.error) : error.message;
                  $loader.hide(); // Ensure loader is hidden on error
                  $analysisContainer.html(`<p style="color:red; text-align:center;"><strong>Analysis Failed:</strong> ${errorMessage}</p>`).show();
              } finally {
                  $submitBtn.prop('disabled', false);
              }
          });
  
          function renderHeatmap(data, containerId, imgWidth, imgHeight) {
              console.log('==== HEATMAP GENERATION START ====');
              console.log('Rendering heatmap for container:', containerId);
              console.log('Heatmap raw data:', data);
              console.log('Container dimensions:', { width: imgWidth, height: imgHeight });
              
              // Check if heatmap.js is available
              if (typeof h337 === 'undefined') {
                  console.error('ERROR: heatmap.js (h337) is not available. Cannot render heatmap.');
                  return;
              }
              
              if (!data || !Array.isArray(data)) {
                  console.error('ERROR: Invalid heatmap data:', data);
                  return;
              }
              
              const container = document.getElementById(containerId);
              if (!container) {
                  console.error('ERROR: Container not found:', containerId);
                  return;
              }
              console.log('Container element found:', container);

              // Clear any existing heatmap
              console.log('Checking for existing heatmap layer...');
              const existingHeatmap = container.querySelector('.heatmap-layer');
              if (existingHeatmap) {
                  console.log('Existing heatmap layer found, clearing it');
                  existingHeatmap.innerHTML = '';
              } else {
                  console.log('No existing heatmap layer found');
              }

              // Get container dimensions
              console.log('Getting container dimensions from DOM...');
              const containerRect = container.getBoundingClientRect();
              const containerWidth = containerRect.width;
              const containerHeight = containerRect.height;
              console.log('Actual container dimensions from DOM:', { width: containerWidth, height: containerHeight });
              
              // Create heatmap instance with proper configuration
              console.log('Creating heatmap.js instance with configuration...');
              const radius = Math.min(containerWidth, containerHeight) * 0.1;
              console.log('Calculated radius for heatmap:', radius);
              
              try {
                  // Use the heatmap layer instead of the container for better positioning
                  const heatmapLayer = container.querySelector('.heatmap-layer');
                  console.log('Using heatmap layer for rendering:', heatmapLayer);
                  
                  const heatmapInstance = h337.create({
                      container: heatmapLayer,
                      radius: radius,
                      maxOpacity: 0.6,
                      minOpacity: 0,
                      blur: 0.75,
                      gradient: {
                          '.5': 'blue',
                          '.8': 'red',
                          '.95': 'white'
                      }
                  });
                  console.log('Heatmap instance created successfully');

                  // Convert percentage-based coordinates to pixels
                  console.log('Converting percentage coordinates to pixel values...');
                  const formattedData = data.map((pt, index) => {
                      // Convert percentage to pixel values
                      const x = (pt.x / 100) * containerWidth;
                      const y = (pt.y / 100) * containerHeight;
                      
                      console.log(`Point ${index}: ${pt.x}% → ${x}px, ${pt.y}% → ${y}px`);
                      
                      return {
                          x: x,
                          y: y,
                          // Ensure intensity is between 0 and 1, default to 0.6 for visibility
                          value: pt.intensity ? Math.min(Math.max(pt.intensity, 0.3), 1) : 0.6
                      };
                  });
                  
                  // Add data points if none exist (for testing)
                  if (formattedData.length === 0) {
                      console.log('No heatmap data points found, adding sample points for testing');
                      // Add sample points across the container
                      for (let i = 0; i < 10; i++) {
                          formattedData.push({
                              x: Math.random() * containerWidth,
                              y: Math.random() * containerHeight,
                              value: Math.random() * 0.5 + 0.5 // Value between 0.5 and 1
                          });
                      }
                  }

                  console.log('All points converted to pixels:', formattedData);

                  // Set the data with proper max value
                  console.log('Setting data to heatmap instance...');
                  heatmapInstance.setData({
                      max: 1,
                      data: formattedData
                  });
                  
                  // Adjust the configuration after setting data for better visibility
                  console.log('Adjusting heatmap configuration for better visibility...');
                  heatmapInstance.configure({
                      radius: radius,
                      maxOpacity: 0.8,
                      minOpacity: 0.2,
                      blur: 0.9,
                      gradient: {
                          '0.4': 'blue',
                          '0.6': 'cyan',
                          '0.7': 'lime',
                          '0.8': 'yellow',
                          '1.0': 'red'
                      }
                  });
                  console.log('Data set to heatmap instance successfully');
                  
                  // Log DOM changes
                  console.log('DOM after heatmap rendering:');
                  console.log('- Canvas elements in container:', container.querySelectorAll('canvas').length);
                  
                  // Check if canvas was created
                  const canvas = container.querySelector('canvas');
                  if (canvas) {
                      console.log('- Canvas dimensions:', { width: canvas.width, height: canvas.height });
                  } else {
                      console.warn('WARNING: No canvas element found after heatmap rendering');
                  }
                  
                  console.log('Heatmap rendered successfully');
              } catch (error) {
                  console.error('ERROR during heatmap creation:', error);
              }
              
              console.log('==== HEATMAP GENERATION COMPLETE ====');
          }
          
          function renderSuggestions(frameAnalysis, imgElement, containerId, imgWidth, imgHeight) {
              if (!frameAnalysis) return;
              const container = document.getElementById(containerId);
              if (!container) return;

              console.log('Rendering suggestions:', frameAnalysis.suggestions);

              // Create popup elements and append them to container instead of body
              const suggestionPopup = document.createElement('div');
              suggestionPopup.className = 'suggestion-popup';
              suggestionPopup.style.position = 'absolute';
              container.appendChild(suggestionPopup);

              const dropoffPopup = document.createElement('div');
              dropoffPopup.className = 'dropoff-popup';
              dropoffPopup.style.position = 'absolute';
              container.appendChild(dropoffPopup);

              const positivePopup = document.createElement('div');
              positivePopup.className = 'positive-popup';
              positivePopup.style.position = 'absolute';
              container.appendChild(positivePopup);

              let activeMarker = null;

              // Function to center popup over the image container
              function centerPopup(popup) {
                  const containerRect = container.getBoundingClientRect();
                  const popupRect = popup.getBoundingClientRect();
                  
                  // Calculate center position relative to the container
                  const top = (containerRect.height - popupRect.height) / 2;
                  const left = (containerRect.width - popupRect.width) / 2;
                  
                  popup.style.top = `${top}px`;
                  popup.style.left = `${left}px`;

                  // Scroll the popup into view
                  popup.scrollIntoView({ behavior: 'smooth', block: 'center' });
              }

              // Render suggestion markers
              if (frameAnalysis.suggestions && Array.isArray(frameAnalysis.suggestions)) {
                  frameAnalysis.suggestions.forEach((s, idx) => {
                      // Skip if suggestion is empty, null, or undefined
                      if (!s.suggestion || s.suggestion.trim() === '') {
                          console.log(`Skipping empty suggestion marker at index ${idx}`);
                          return;
                      }

                      const marker = document.createElement('div');
                      marker.className = 'ux-suggestion-marker';
                      
                      marker.style.left = `${s.x}%`;
                      marker.style.top = `${s.y}%`;
                      
                      marker.innerHTML = `<span>${idx + 1}</span>`;
                      
                      marker.onclick = (e) => { 
                          e.stopPropagation();
                          
                          // Toggle popup if clicking the same marker
                          if (activeMarker === marker) {
                              suggestionPopup.classList.remove('active');
                              activeMarker = null;
                              return;
                          }
                          
                          // Update popup content
                          suggestionPopup.innerHTML = `
                              <h3>Suggestion #${idx + 1}</h3>
                              <p>${s.suggestion}</p>
                          `;
                          
                          // Center popup over the image container
                          centerPopup(suggestionPopup);
                          
                          // Show popup
                          suggestionPopup.classList.add('active');
                          dropoffPopup.classList.remove('active');
                          positivePopup.classList.remove('active');
                          activeMarker = marker;
                      };
                      
                      console.log('Adding suggestion marker at:', { x: s.x, y: s.y, suggestion: s.suggestion });
                      container.appendChild(marker);
                  });
              }

              // Render positive points if they exist
              if (frameAnalysis.positive_points && Array.isArray(frameAnalysis.positive_points)) {
                  console.log('Found positive points:', frameAnalysis.positive_points);
                  frameAnalysis.positive_points.forEach((p, idx) => {
                      // Skip if reason is empty, null, or undefined
                      if (!p.reason || p.reason.trim() === '') {
                          console.log(`Skipping empty positive point marker at index ${idx}`);
                          return;
                      }

                      const marker = document.createElement('div');
                      marker.className = 'ux-positive-marker';
                      
                      marker.style.left = `${p.x}%`;
                      marker.style.top = `${p.y}%`;
                      
                      marker.innerHTML = `<span>✨</span>`;
                      
                      marker.onclick = (e) => { 
                          e.stopPropagation();
                          
                          // Toggle popup if clicking the same marker
                          if (activeMarker === marker) {
                              positivePopup.classList.remove('active');
                              activeMarker = null;
                              return;
                          }
                          
                          // Update popup content
                          positivePopup.innerHTML = `
                              <h3>Positive Point #${idx + 1}</h3>
                              <p>${p.reason}</p>
                          `;
                          
                          // Center popup over the image container
                          centerPopup(positivePopup);
                          
                          // Show popup
                          positivePopup.classList.add('active');
                          suggestionPopup.classList.remove('active');
                          dropoffPopup.classList.remove('active');
                          activeMarker = marker;
                      };
                      
                      console.log('Adding positive point marker at:', { x: p.x, y: p.y, reason: p.reason });
                      container.appendChild(marker);
                  });
              } else {
                  console.log('No positive points found in frame analysis');
              }

              // Render drop-off markers if they exist
              if (frameAnalysis.drop_off_points && Array.isArray(frameAnalysis.drop_off_points)) {
                  console.log('Found drop-off points:', frameAnalysis.drop_off_points);
                  frameAnalysis.drop_off_points.forEach((d, idx) => {
                      // Skip if reason is empty, null, or undefined
                      if (!d.reason || d.reason.trim() === '') {
                          console.log(`Skipping empty dropoff marker at index ${idx}`);
                          return;
                      }

                      const marker = document.createElement('div');
                      marker.className = 'ux-dropoff-marker';
                      
                      marker.style.left = `${d.x}%`;
                      marker.style.top = `${d.y}%`;
                      
                      marker.innerHTML = `<span>⚠️</span>`;
                      
                      marker.onclick = (e) => { 
                          e.stopPropagation();
                          
                          // Toggle popup if clicking the same marker
                          if (activeMarker === marker) {
                              dropoffPopup.classList.remove('active');
                              activeMarker = null;
                              return;
                          }
                          
                          // Update popup content
                          dropoffPopup.innerHTML = `
                              <h3>Drop-off Point #${idx + 1}</h3>
                              <p>${d.reason}</p>
                          `;
                          
                          // Center popup over the image container
                          centerPopup(dropoffPopup);
                          
                          // Show popup
                          dropoffPopup.classList.add('active');
                          suggestionPopup.classList.remove('active');
                          positivePopup.classList.remove('active');
                          activeMarker = marker;
                      };
                      
                      console.log('Adding drop-off marker at:', { x: d.x, y: d.y, reason: d.reason });
                      container.appendChild(marker);
                  });
              } else {
                  console.log('No drop-off points found in frame analysis');
              }

              // Close popups when clicking outside
              document.addEventListener('click', (e) => {
                  if (!e.target.closest('.ux-suggestion-marker') && 
                      !e.target.closest('.ux-dropoff-marker') && 
                      !e.target.closest('.ux-positive-marker')) {
                      suggestionPopup.classList.remove('active');
                      dropoffPopup.classList.remove('active');
                      positivePopup.classList.remove('active');
                      activeMarker = null;
                  }
              });
          }
          // Render mobile finger reach chart
          function renderFingerReachChart(containerId, containerWidth, containerHeight, orientation = 'portrait') {
              console.log('==== FINGER REACH CHART GENERATION START ====');
              console.log('Rendering finger reach chart for container:', containerId);
              console.log('Container dimensions:', { width: containerWidth, height: containerHeight });
              
              const container = document.getElementById(containerId);
              if (!container) {
                  console.error('ERROR: Container not found:', containerId);
                  return;
              }
              
              const reachLayer = container.querySelector('.reach-layer');
              if (!reachLayer) {
                  console.error('ERROR: Reach layer not found in container');
                  return;
              }
              
              // Clear any existing content
              reachLayer.innerHTML = '';
              
              // Create a canvas element
              const canvas = document.createElement('canvas');
              canvas.width = containerWidth;
              canvas.height = containerHeight;
              canvas.style.position = 'absolute';
              canvas.style.top = '0';
              canvas.style.left = '0';
              canvas.style.width = '100%';
              canvas.style.height = '100%';
              
              // Add the canvas to the reach layer
              reachLayer.appendChild(canvas);
              
              const ctx = canvas.getContext('2d');
              
              // Draw the reach zones based on orientation
              if (orientation === 'portrait') {
                  // Values are based on thumb reach research for average hand size
                  // Bottom center is the reference point (thumb position)
                  const centerX = containerWidth / 2;
                  const bottomY = containerHeight;
                  
                  // Easy reach zone (green) - approx 40% of screen from bottom
                  const easyReachGradient = ctx.createRadialGradient(
                      centerX, bottomY, 0,
                      centerX, bottomY, containerHeight * 0.4
                  );
                  easyReachGradient.addColorStop(0, 'rgba(46, 213, 115, 0.5)'); // Green
                  easyReachGradient.addColorStop(1, 'rgba(46, 213, 115, 0)');
                  
                  // Stretch zone (yellow) - approx 70% of screen from bottom
                  const stretchReachGradient = ctx.createRadialGradient(
                      centerX, bottomY, containerHeight * 0.4,
                      centerX, bottomY, containerHeight * 0.7
                  );
                  stretchReachGradient.addColorStop(0, 'rgba(255, 204, 0, 0.5)'); // Yellow
                  stretchReachGradient.addColorStop(1, 'rgba(255, 204, 0, 0)');
                  
                  // Difficult zone (red) - rest of the screen
                  const hardReachGradient = ctx.createRadialGradient(
                      centerX, bottomY, containerHeight * 0.7,
                      centerX, bottomY, containerHeight
                  );
                  hardReachGradient.addColorStop(0, 'rgba(231, 76, 60, 0.5)'); // Red
                  hardReachGradient.addColorStop(1, 'rgba(231, 76, 60, 0)');
                  
                  // Render the zones from hardest to easiest reach
                  ctx.fillStyle = hardReachGradient;
                  ctx.fillRect(0, 0, containerWidth, containerHeight);
                  
                  ctx.fillStyle = stretchReachGradient;
                  ctx.beginPath();
                  ctx.arc(centerX, bottomY, containerHeight * 0.7, 0, Math.PI, true);
                  ctx.fill();
                  
                  ctx.fillStyle = easyReachGradient;
                  ctx.beginPath();
                  ctx.arc(centerX, bottomY, containerHeight * 0.4, 0, Math.PI, true);
                  ctx.fill();
              } else {
                  // Landscape mode - adjust for right thumb position
                  const rightX = containerWidth;
                  const centerY = containerHeight / 2;
                  
                  // Easy reach zone (green) - approx 40% of screen from right
                  const easyReachGradient = ctx.createRadialGradient(
                      rightX, centerY, 0,
                      rightX, centerY, containerWidth * 0.4
                  );
                  easyReachGradient.addColorStop(0, 'rgba(46, 213, 115, 0.6)'); // Green
                  easyReachGradient.addColorStop(1, 'rgba(46, 213, 115, 0)');
                  
                  // Stretch zone (yellow) - approx 70% of screen from right
                  const stretchReachGradient = ctx.createRadialGradient(
                      rightX, centerY, containerWidth * 0.4,
                      rightX, centerY, containerWidth * 0.7
                  );
                  stretchReachGradient.addColorStop(0, 'rgba(255, 204, 0, 0.6)'); // Yellow
                  stretchReachGradient.addColorStop(1, 'rgba(255, 204, 0, 0)');
                  
                  // Difficult zone (red) - rest of the screen
                  const hardReachGradient = ctx.createRadialGradient(
                      rightX, centerY, containerWidth * 0.7,
                      rightX, centerY, containerWidth
                  );
                  hardReachGradient.addColorStop(0, 'rgba(231, 76, 60, 0.6)'); // Red
                  hardReachGradient.addColorStop(1, 'rgba(231, 76, 60, 0)');
                  
                  // Render the zones from hardest to easiest reach
                  ctx.fillStyle = hardReachGradient;
                  ctx.fillRect(0, 0, containerWidth, containerHeight);
                  
                  ctx.fillStyle = stretchReachGradient;
                  ctx.beginPath();
                  ctx.arc(rightX, centerY, containerWidth * 0.7, -Math.PI/2, Math.PI/2, true);
                  ctx.fill();
                  
                  ctx.fillStyle = easyReachGradient;
                  ctx.beginPath();
                  ctx.arc(rightX, centerY, containerWidth * 0.4, -Math.PI/2, Math.PI/2, true);
                  ctx.fill();
              }
              
              console.log('Finger reach chart rendered successfully');
              console.log('==== FINGER REACH CHART GENERATION COMPLETE ====');
          }
          
          // Set up event listeners for visualization toggle checkboxes
          $(document).on('change', '.viz-toggle-checkbox', function() {
              const frameId = $(this).data('frame');
              const target = $(this).data('target');
              const isChecked = $(this).prop('checked');
              
              const container = $(`#heatmap-container-${frameId}`);
              
              if (target === 'heatmap') {
                  const heatmapLayer = container.find('.heatmap-layer');
                  if (isChecked) {
                      heatmapLayer.addClass('active');
                  } else {
                      heatmapLayer.removeClass('active');
                  }
              } else if (target === 'reach') {
                  const reachLayer = container.find('.reach-layer');
                  const reachLegend = $(`#reach-legend-${frameId}`);
                  if (isChecked) {
                      reachLayer.addClass('active');
                      reachLegend.addClass('active');
                      
                      // Get container dimensions
                      const containerWidth = container.width();
                      const containerHeight = container.height();
                      
                      // Determine orientation based on aspect ratio
                      const orientation = containerWidth > containerHeight ? 'landscape' : 'portrait';
                      
                      // Render the finger reach chart if not already rendered
                      renderFingerReachChart(`heatmap-container-${frameId}`, containerWidth, containerHeight, orientation);
                  } else {
                      reachLayer.removeClass('active');
                      reachLegend.removeClass('active');
                  }
              } else if (target === 'suggestions') {
                  container.find('.ux-suggestion-marker').toggleClass('active', isChecked);
              } else if (target === 'dropoffs') {
                  container.find('.ux-dropoff-marker').toggleClass('active', isChecked);
              } else if (target === 'positives') {
                  container.find('.ux-positive-marker').toggleClass('active', isChecked);
              }
          });
          

          $(document).on('click', '.enhance-btn', function() {
            const frameId = $(this).data('frame');
            // Convert the frame ID from hyphen format to colon format
            const originalFrameId = frameId.replace(/-/g, ':');
            const figmaFileId = $('#figmaFileId').val();
            const figmaToken = getSelectedToken();
    
            console.log('Enhance button clicked for frame:', frameId);
            console.log('Original frame ID:', originalFrameId);
            console.log('Frame analysis data:', window.frameAnalysisData);
    
            const frameAnalysis = window.frameAnalysisData?.[originalFrameId];
    
            if (!frameAnalysis) {
                console.error('No analysis data found for frame:', originalFrameId);
                alert('No analysis data available for this frame. Please run the analysis first.');
                return;
            }
    
            if (frameAnalysis.drop_off_points) {
                const url = `/design_iteration/?file_id=${figmaFileId}&token=${encodeURIComponent(figmaToken)}&frame_id=${originalFrameId}&dropoffs=${encodeURIComponent(JSON.stringify(frameAnalysis.drop_off_points))}`;
                console.log('Opening URL:', url);
                window.open(url, '_blank');
            } else {
                console.warn('No drop-off points found for frame:', originalFrameId);
                alert('No drop-off points available for enhancement.');
            }
        });
          
          // Initialize default state - all layers and markers hidden
          $(document).ready(function() {
              // Hide all layers
              $('.heatmap-layer').removeClass('active');
              $('.reach-layer').removeClass('active');
              $('.reach-legend').removeClass('active');
              $('.ux-suggestion-marker').removeClass('active');
              $('.ux-dropoff-marker').removeClass('active');
              $('.ux-positive-marker').removeClass('active');
              
              // Ensure all checkboxes are unchecked by default
              $('.viz-toggle-checkbox').prop('checked', false);
              
              // Reset all toggle buttons to their default state
              $('.viz-toggle-btn').removeClass('active');
              
              // Hide all popups
              $('.suggestion-popup, .dropoff-popup, .positive-popup').removeClass('active');
              
              // Reset all containers to their default state
              $('.design-visualization').addClass('single').removeClass('side-by-side');
              $('.fixed-design-container').removeClass('active').css('height', '0');
          });

          function fetchFigmaFile() {
              const fileId = $('#figmaFileId').val();
              const figmaToken = getSelectedToken();
              
              if (!fileId) {
                  showError('Please enter a Figma File ID');
                  return;
              }
              
              if (!figmaToken) {
                  showError('Please select or enter a Figma access token');
                  return;
              }

              showLoading();
              
              $.ajax({
                  url: '/fetch-figma-file/',
                  method: 'POST',
                  data: JSON.stringify({
                      file_id: fileId,
                      access_token: figmaToken
                  }),
                  contentType: 'application/json',
                  success: function(response) {
                      hideLoading();
                      if (response.error) {
                          showError(response.error);
                          return;
                      }
                      
                      // Store the Figma data
                      window.figmaData = response;
                      
                      // Update the preview
                      updatePreview(response);
                      
                      // Enable the generate button
                      $('#generateBtn').prop('disabled', false);
                  },
                  error: function(xhr) {
                      hideLoading();
                      showError(xhr.responseJSON?.error || 'Failed to fetch Figma file');
                  }
              });
          }

          function renderReport(reportText, containerId) {
              const container = document.getElementById(containerId);
              if (!container) return;

              // Split the report into sections
              const sections = reportText.split('##').filter(section => section.trim());
              
              // Create the report container
              const reportContainer = document.createElement('div');
              reportContainer.className = 'ux-report';

              sections.forEach(section => {
                  const [title, ...content] = section.split('\n');
                  const sectionDiv = document.createElement('div');
                  sectionDiv.className = 'report-section';

                  // Add appropriate class based on section title
                  if (title.includes('Overall Assessment')) {
                      sectionDiv.className += ' overall';
                  } else if (title.includes('Key Strengths')) {
                      sectionDiv.className += ' strengths';
                  } else if (title.includes('Areas for Improvement')) {
                      sectionDiv.className += ' improvements';
                  } else if (title.includes('Recommendations')) {
                      sectionDiv.className += ' recommendations';
                  }

                  // Create heading
                  const heading = document.createElement('h2');
                  heading.textContent = title.trim();
                  sectionDiv.appendChild(heading);

                  // Process content
                  const contentText = content.join('\n').trim();
                  const paragraphs = contentText.split('\n\n');

                  paragraphs.forEach(paragraph => {
                      if (paragraph.trim().startsWith('•')) {
                          // This is a bullet point list
                          const ul = document.createElement('ul');
                          const items = paragraph.split('\n');
                          
                          items.forEach(item => {
                              if (item.trim()) {
                                  const li = document.createElement('li');
                                  li.textContent = item.replace('•', '').trim();
                                  ul.appendChild(li);
                              }
                          });
                          
                          sectionDiv.appendChild(ul);
                      } else {
                          // This is a regular paragraph
                          const p = document.createElement('p');
                          p.textContent = paragraph.trim();
                          sectionDiv.appendChild(p);
                      }
                  });

                  reportContainer.appendChild(sectionDiv);
              });

              container.innerHTML = '';
              container.appendChild(reportContainer);
          }
      });
      </script>
</body>
</html>
